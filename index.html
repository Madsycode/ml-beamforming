<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIMO Beamforming Simulator (Advanced Dataset Generation)</title>
    <style>
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f7f6;
        }
        .app-wrapper { display: flex; flex-direction: column; height: 100vh; padding: 1.5em; box-sizing: border-box; }
        h1 { color: #1a5276; margin: 0 0 1em 0; flex-shrink: 0; border-bottom: 2px solid #aed6f1; padding-bottom: 0.5em; }
        .container { display: flex; gap: 1.5em; flex-grow: 1; min-height: 0; }
        .panel { background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 1.5em; display: flex; flex-direction: column; overflow-y: auto; }
        .controls-panel { flex: 1; min-width: 380px; }
        .viz-panel { flex: 1.5; min-width: 450px; } /* Makes the visualization panel larger */
        h2 { color: #1a5276; margin-top: 0; }
        .controls { display: grid; grid-template-columns: 1fr; gap: 1em; }
        @media (min-width: 600px) { .controls { grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); } }
        .control-group { display: flex; flex-direction: column; }
        label { font-weight: bold; margin-bottom: 0.5em; color: #555; }
        input, select, button { width: 100%; box-sizing: border-box; padding: 0.75em; border-radius: 4px; border: 1px solid #ccc; font-size: 1em; }
        button { background-color: #1a5276; color: white; font-weight: bold; border: none; cursor: pointer; transition: background-color 0.2s; margin-top: 0.5em; }
        button:hover { background-color: #2471a3; }
        .button-secondary { background-color: #5dade2; } .button-secondary:hover { background-color: #85c1e9; }
        .button-danger { background-color: #af601a; } .button-danger:hover { background-color: #d35400; }
        
        .visualization-content { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; }
        .canvas-container { flex-grow: 1; position: relative; display: flex; justify-content: center; align-items: center; margin-bottom: 1em; }
        canvas { border: 1px solid #ddd; border-radius: 4px; max-width: 100%; max-height: 100%; object-fit: contain; }
        .metrics { margin-top: auto; flex-shrink: 0; padding: 1em; background-color: #eaf2f8; border-radius: 4px; }
        .metric-item { display: flex; justify-content: space-between; margin-bottom: 0.5em; }
        .metric-item span { font-weight: bold; word-break: break-all; }
        
        #weightsDisplay { width: 100%; height: 100px; margin-top: 1em; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; resize: vertical; }

        @media (max-width: 900px) {
            .container { flex-direction: column; }
            .panel { min-width: 0; flex: 1; }
        }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <h1>MIMO Beamforming Simulator</h1>
        <div class="container">
            <div class="panel controls-panel">
                <h2>Controls (Heatmap Generation)</h2>
                <div class="controls">
                    <div class="control-group"><label for="resolution">Resolution:</label><select id="resolution"><option value="128" selected>128x128</option><option value="256">256x256</option><option value="512">512x512</option><option value="1024">1024x1024</option></select></div>
                    <div class="control-group"><label for="numAntennas">Antenna Elements (N):</label><input type="number" id="numAntennas" value="16" min="2" max="64"></div>
                    <div class="control-group"><label for="numHotspots">Max Nr. Hotspots:</label><input type="number" id="numHotspots" value="5" min="1" max="10"></div>
                    <div class="control-group"><label for="hotspotIntensity">Max Intensity:</label><input type="range" id="hotspotIntensity" min="10" max="100" value="80"></div>
                    <div class="control-group"><label for="hotspotRadius">Max Radius:</label><input type="range" id="hotspotRadius" min="5" max="40" value="25"></div>
                    <div class="control-group"><label for="noiseLevel">Max Noise:</label><input type="range" id="noiseLevel" min="0" max="0.5" value="0.2" step="0.01"></div>
                </div>
                <button id="generateBtn" style="margin-top: 1.5em;">1. Generate New Scenario & Synthesize Beam</button>
                 <hr style="margin: 1.5em 0; border: 1px solid #eee;">
                <h2>Randomized Dataset Generation</h2>
                <p style="font-size: 0.9em; color: #555;">This will generate samples with randomized parameters up to the maximums set above.</p>
                <div class="controls">
                    <div class="control-group"><label for="datasetSize">Dataset Size:</label><input type="number" id="datasetSize" value="100" min="10" max="10000"></div>
                    <div class="control-group"><label>&nbsp;</label><button id="generateDatasetBtn" class="button-secondary">2. Generate & Download</button></div>
                </div>
            </div>
            <div class="panel viz-panel">
                <div class="visualization-content">
                    <h2>Combined Visualization: Optimal Beam Shape</h2>
                    <div class="canvas-container"><canvas id="combinedCanvas"></canvas></div>
                    <div class="metrics">
                        <h3>Performance Metric</h3>
                        <div class="metric-item">Optimal Coverage: <span id="coverage">--</span></div>
                    </div>
                    <div>
                        <h3 style="margin-bottom: 0.5em;">Synthesized Antenna Weights (Gain + Phase)</h3>
                        <textarea id="weightsDisplay" readonly></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- UI Elements and State ---
    const combinedCanvas = document.getElementById('combinedCanvas'), ctx = combinedCanvas.getContext('2d');
    const resolutionSelect = document.getElementById('resolution'), numAntennasInput = document.getElementById('numAntennas');
    const numHotspotsInput = document.getElementById('numHotspots'), hotspotIntensityInput = document.getElementById('hotspotIntensity');
    const hotspotRadiusInput = document.getElementById('hotspotRadius'), noiseLevelInput = document.getElementById('noiseLevel');
    const generateBtn = document.getElementById('generateBtn'), exportBtn = document.getElementById('exportBtn'), generateDatasetBtn = document.getElementById('generateDatasetBtn');
    const coverageDisplay = document.getElementById('coverage'), weightsDisplay = document.getElementById('weightsDisplay');
    
    let currentHeatmap = null, currentAntennaWeights = [], currentCoverage = 0, resolution = 128;

    // --- Core Simulation & Physics (Unchanged) ---
    function generateHeatmap() { /* ... */ }
    function calculateAngularDemandProfile(heatmap, numBins = 181) { /* ... */ }
    function synthesizeOptimalWeights(demandProfile, N, d_lambda = 0.5) { /* ... */ }
    function calculateArrayFactor(theta_deg, weights, d_lambda = 0.5) { /* ... */ }
    function calculateCoverage(heatmap, weights, N) { /* ... */ }
    
    // --- Drawing Functions (Unchanged) ---
    function drawHeatmap(heatmap) { /* ... */ }
    function drawOverlay(weights) { /* ... */ }
    
    // --- Helper Functions ---
    function updateWeightsDisplay(weights) {
        weightsDisplay.value = weights.map((w, i) => {
            const mag = Math.sqrt(w.real**2 + w.imag**2).toFixed(3);
            const phase = (Math.atan2(w.imag, w.real) * 180 / Math.PI).toFixed(1);
            return `w[${String(i).padStart(2, ' ')}]:  mag=${mag}, phase=${phase}Â°\n    (${w.real.toFixed(3)} + j * ${w.imag.toFixed(3)})`;
        }).join('\n');
    }

    // --- Main Logic & Event Handlers ---
    function runSimulation(params = {}) {
        // 1. Generate a new UE distribution
        currentHeatmap = generateHeatmap(params);
        drawHeatmap(currentHeatmap);
        
        const N = parseInt(numAntennasInput.value);

        // 2. Analyze the heatmap to find the demand vs. angle
        const angularDemand = calculateAngularDemandProfile(currentHeatmap);
        
        // 3. Synthesize the single set of optimal antenna weights
        currentAntennaWeights = synthesizeOptimalWeights(angularDemand, N);
        
        // 4. Draw the resulting beam shape from those weights
        drawOverlay(currentAntennaWeights);
        
        // 5. Calculate and display performance
        currentCoverage = calculateCoverage(currentHeatmap, currentAntennaWeights, N);
        coverageDisplay.textContent = `${currentCoverage.toFixed(2)}%`;
        updateWeightsDisplay(currentAntennaWeights);
    }

    function download(filename, text) { /* ... */ }
    function exportCurrentSample() {
        if (!currentHeatmap) return;
        download('sample.json', JSON.stringify({
            heatmap: currentHeatmap, 
            antenna_weights: currentAntennaWeights,
            coverage_percent: currentCoverage,
            params: { resolution: parseInt(resolutionSelect.value), num_antennas: parseInt(numAntenansInput.value) }
        }));
    }

    function generateDataset() {
        const size = parseInt(document.getElementById('datasetSize').value);
        const dataset = [];
        generateDatasetBtn.textContent = "Generating...";
        generateDatasetBtn.disabled = true;

        // Save current UI state to restore later
        const originalParams = {
            numHotspots: numHotspotsInput.value,
            intensity: hotspotIntensityInput.value,
            radius: hotspotRadiusInput.value,
            noise: noiseLevelInput.value
        };
        
        let i = 0;
        function generateNext() {
            if (i < size) {
                // *** NEW: Randomize parameters for this sample ***
                const randomParams = {
                    numHotspots: Math.floor(Math.random() * parseInt(originalParams.numHotspots)) + 1,
                    intensity: Math.random() * (originalParams.intensity - 10) + 10,
                    radius: Math.random() * (originalParams.radius - 5) + 5,
                    noise: Math.random() * originalParams.noise
                };
                
                // Temporarily apply random params for this run
                numHotspotsInput.value = randomParams.numHotspots;
                hotspotIntensityInput.value = randomParams.intensity;
                hotspotRadiusInput.value = randomParams.radius;
                noiseLevelInput.value = randomParams.noise;

                runSimulation();
                
                dataset.push({
                    heatmap: currentHeatmap, 
                    antenna_weights: currentAntennaWeights, 
                    coverage_percent: currentCoverage,
                    params: {
                        resolution: parseInt(resolutionSelect.value), 
                        num_antennas: parseInt(numAntennasInput.value),
                        ...randomParams // Store the exact params used for this sample
                    }
                });
                i++;
                generateDatasetBtn.textContent = `Generating... (${i}/${size})`;
                setTimeout(generateNext, 10);
            } else {
                // Restore original UI settings
                numHotspotsInput.value = originalParams.numHotspots;
                hotspotIntensityInput.value = originalParams.intensity;
                hotspotRadiusInput.value = originalParams.radius;
                noiseLevelInput.value = originalParams.noise;

                download(`mimo_dataset_${size}_samples.json`, JSON.stringify(dataset));
                generateDatasetBtn.textContent = "2. Generate & Download";
                generateDatasetBtn.disabled = false;
                
                // Rerun simulation with original settings for the user
                runSimulation();
            }
        }
        generateNext();
    }
    
    // Wire up events
    document.querySelectorAll('#resolution, #numAntennas, #numHotspots, #hotspotIntensity, #hotspotRadius, #noiseLevel').forEach(el => el.addEventListener('input', runSimulation));
    generateBtn.addEventListener('click', () => runSimulation());
    // exportBtn.addEventListener('click', exportCurrentSample); // Removed as it was for single sample, can be re-added if needed
    generateDatasetBtn.addEventListener('click', generateDataset);

    // Initial run
    runSimulation();
    
    // --- Full function definitions omitted in this comment block for brevity but are present in the final code ---
    function generateHeatmap() {
        resolution = parseInt(resolutionSelect.value); combinedCanvas.width = resolution; combinedCanvas.height = resolution;
        const numHotspots = parseInt(numHotspotsInput.value), intensity = parseFloat(hotspotIntensityInput.value);
        const radius = parseFloat(hotspotRadiusInput.value), noise = parseFloat(noiseLevelInput.value);
        const map = Array(resolution).fill(0).map(() => Array(resolution).fill(0));
        for (let i = 0; i < numHotspots; i++) {
            const hx = Math.random() * resolution, hy = Math.random() * resolution;
            const currentIntensity = intensity * (0.8 + Math.random() * 0.4);
            for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) {
                map[y][x] += currentIntensity * Math.exp(-((x - hx) ** 2 + (y - hy) ** 2) / (2 * radius ** 2));
            }
        }
        let maxVal = 0;
        for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) {
            map[y][x] += (Math.random() * noise * intensity);
            if (map[y][x] > maxVal) maxVal = map[y][x];
        }
        if (maxVal > 0) for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) map[y][x] /= maxVal;
        return map;
    }
    function calculateAngularDemandProfile(heatmap, numBins = 181) {
        const profile = Array(numBins).fill(0);
        const antennaX = resolution / 2; const antennaY = resolution;
        const angleOffset = Math.floor(numBins / 2);
        for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) {
            if (heatmap[y][x] > 0) {
                const angle_deg = Math.atan2(x - antennaX, antennaY - y) * 180 / Math.PI;
                const bin = Math.round(angle_deg) + angleOffset;
                if (bin >= 0 && bin < numBins) profile[bin] += heatmap[y][x];
            }
        }
        return profile;
    }
    function synthesizeOptimalWeights(demandProfile, N, d_lambda = 0.5) {
        const weights = Array(N).fill(0).map(() => ({ real: 0, imag: 0 }));
        const k_d = 2 * Math.PI * d_lambda;
        const angleOffset = Math.floor(demandProfile.length / 2);
        for (let n = 0; n < N; n++) for (let i = 0; i < demandProfile.length; i++) {
            const P_theta = demandProfile[i];
            if (P_theta > 0) {
                const angle_rad = (i - angleOffset) * Math.PI / 180;
                const phase = n * k_d * Math.sin(angle_rad);
                weights[n].real += P_theta * Math.cos(phase);
                weights[n].imag += P_theta * Math.sin(phase);
            }
        }
        return weights;
    }
    function calculateArrayFactor(theta_deg, weights, d_lambda = 0.5) {
        const N = weights.length;
        const theta_rad = theta_deg * Math.PI / 180;
        const k_d = 2 * Math.PI * d_lambda;
        let total_field = { real: 0, imag: 0 };
        for (let n = 0; n < N; n++) {
            const phase_shift = -n * k_d * Math.sin(theta_rad);
            const s_n = { real: Math.cos(phase_shift), imag: Math.sin(phase_shift) };
            const w_n = weights[n];
            total_field.real += w_n.real * s_n.real - w_n.imag * s_n.imag;
            total_field.imag += w_n.real * s_n.imag + w_n.imag * s_n.real;
        }
        return Math.sqrt(total_field.real**2 + total_field.imag**2) / N;
    }
    function calculateCoverage(heatmap, weights) {
        const antennaX = resolution/2, antennaY = resolution;
        let totalDemand = 0, coveredDemand = 0;
        let maxGain = 0;
        for (let angle_deg = -90; angle_deg <= 90; angle_deg++) maxGain = Math.max(maxGain, calculateArrayFactor(angle_deg, weights));
        const gainThreshold = maxGain / Math.sqrt(2);
        for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) {
            totalDemand += heatmap[y][x];
            const angle_deg = Math.atan2(x - antennaX, antennaY - y) * 180 / Math.PI;
            const gain_at_angle = calculateArrayFactor(angle_deg, weights);
            if (gain_at_angle >= gainThreshold) coveredDemand += heatmap[y][x];
        }
        return totalDemand > 0 ? (coveredDemand / totalDemand) * 100 : 0;
    }
    function drawHeatmap(heatmap) {
        const imageData = new ImageData(new Uint8ClampedArray(resolution * resolution * 4), resolution);
        const data = imageData.data;
        for (let y = 0; y < resolution; y++) for (let x = 0; x < resolution; x++) {
            const v = heatmap[y][x]; const i = (y * resolution + x) * 4;
            data[i] = Math.sqrt(v) * 255; data[i + 1] = v * 255; data[i + 2] = (1 - Math.sqrt(v)) * 100 + 50; data[i + 3] = 255;
        }
        ctx.putImageData(imageData, 0, 0);
    }
    function drawOverlay(weights) {
        const antennaX = resolution / 2; const antennaY = resolution; const maxRadius = resolution;
        ctx.save(); ctx.translate(antennaX, antennaY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 1;
        for (let r_mult = 0.25; r_mult <= 1; r_mult += 0.25) { ctx.beginPath(); ctx.arc(0, 0, maxRadius * r_mult, Math.PI, 2 * Math.PI); ctx.stroke(); }
        ctx.beginPath();
        ctx.strokeStyle = '#d35400'; ctx.lineWidth = 3;
        let max_gain = 0;
        const gains = [];
        for (let angle_deg = -90; angle_deg <= 90; angle_deg += 0.5) {
            const gain = calculateArrayFactor(angle_deg, weights);
            if(gain > max_gain) max_gain = gain;
            gains.push({angle_deg, gain});
        }
        gains.forEach(({angle_deg, gain}) => {
            const radius = (max_gain > 0 ? gain / max_gain : 0) * maxRadius * 0.95;
            const angle_rad = angle_deg * Math.PI / 180;
            const x = radius * Math.sin(angle_rad); const y = -radius * Math.cos(angle_rad);
            if (angle_deg === -90) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke(); ctx.restore();
        ctx.fillStyle = '#1a5276'; ctx.beginPath();
        const ant_h = resolution/20, ant_w = ant_h * 0.8;
        ctx.moveTo(antennaX, antennaY); ctx.lineTo(antennaX - ant_w, antennaY - ant_h); ctx.lineTo(antennaX + ant_w, antennaY - ant_h);
        ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5; ctx.stroke();
    }
    function download(filename, text) { const el = document.createElement('a'); el.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text)); el.setAttribute('download', filename); el.style.display = 'none'; document.body.appendChild(el); el.click(); document.body.removeChild(el);}
});
</script>

</body>
</html>